<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Deux Solitudes</title>
<link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,700;1,400&family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{
  --felt:#0a1f14;--felt2:#0d2518;--border:#1a3d26;
  --gold:#c8a84b;--gold2:#e8c96b;--red:#c0392b;--bluecol:#1a3d7c;
  --text:#d4c9a8;--muted:#4a6355;--card-bg:#f5f0e8;--card-sh:rgba(0,0,0,.45);
  --non:#e05555;--oui:#5b9bd5;--cw:48px;--ch:68px;
}
html{background:var(--felt)}
body{
  font-family:'Courier Prime',monospace;
  background:radial-gradient(ellipse at 20% 10%,#0f2d1a 0%,transparent 60%),
             radial-gradient(ellipse at 80% 90%,#071510 0%,transparent 60%),var(--felt);
  color:var(--text);min-height:100vh;padding:10px 8px 40px;
  max-width:1120px;margin:0 auto;user-select:none;-webkit-user-select:none;
}

/* ── Header ── */
.hdr{display:flex;align-items:baseline;justify-content:space-between;margin-bottom:8px}
h1{font-family:'Cormorant Garamond',serif;font-size:clamp(15px,2.2vw,21px);
   font-weight:400;letter-spacing:.35em;color:var(--gold);text-transform:uppercase;
   text-shadow:0 0 40px rgba(200,168,75,.3)}
.subtitle{font-size:13px;color:var(--gold);letter-spacing:.22em;opacity:.7;margin-top:2px;
          font-family:'Cormorant Garamond',serif;font-style:italic}
.timer{font-size:20px;font-weight:700;color:var(--gold);letter-spacing:.05em;
       font-variant-numeric:tabular-nums;min-width:72px;text-align:right}

/* ── Balance bar ── */
.bal-row{display:flex;align-items:center;gap:10px;margin-bottom:4px}
.bal-score{font-size:13px;font-weight:700;width:36px;flex-shrink:0}
.bal-score.non{color:var(--non);text-align:right}
.bal-score.oui{color:var(--oui)}
.bal-track{flex:1;height:6px;background:#0d1f16;border-radius:99px;
           overflow:hidden;border:1px solid var(--border);position:relative}
.bal-fill{position:absolute;inset:0;width:50%;
          background:linear-gradient(90deg,var(--non),#c8703a);
          border-radius:99px;transition:width .5s cubic-bezier(.4,0,.2,1)}
.bal-mid{position:absolute;left:50%;top:-3px;bottom:-3px;
         width:2px;background:#1a3d26;transform:translateX(-50%)}
.bal-lbl{text-align:center;font-size:9px;color:var(--muted);
         letter-spacing:.1em;margin-bottom:8px;height:13px}
.bal-lbl.eq{color:#4caf7d}

/* ── Turn indicator ── */
.turn-bar{display:flex;align-items:center;justify-content:center;gap:16px;
          margin-bottom:10px;height:22px}
.turn-chip{font-size:9px;letter-spacing:.2em;text-transform:uppercase;
           padding:3px 12px;border-radius:99px;border:1px solid;
           transition:all .25s;font-weight:700}
.turn-chip.non{border-color:var(--non);color:var(--non)}
.turn-chip.oui{border-color:var(--oui);color:var(--oui)}
.turn-chip.active-non{background:var(--non);color:#fff;
  box-shadow:0 0 12px rgba(224,85,85,.4)}
.turn-chip.active-oui{background:var(--oui);color:#fff;
  box-shadow:0 0 12px rgba(91,155,213,.4)}
.turn-arrow{font-size:11px;color:var(--muted)}
.skip-notice{font-size:9px;color:var(--muted);letter-spacing:.12em;
             animation:fadein .3s;text-align:center;margin-bottom:6px;height:12px}
@keyframes fadein{from{opacity:0}to{opacity:1}}

/* ── 3-column layout ── */
.game-layout{display:grid;grid-template-columns:1fr 90px 1fr;gap:10px;align-items:start}
@media(max-width:680px){
  .game-layout{grid-template-columns:1fr}
  .center-col{order:-1}
}

/* ── Boards ── */
.board{
  background:repeating-linear-gradient(45deg,transparent,transparent 28px,
    rgba(255,255,255,.012) 28px,rgba(255,255,255,.012) 29px),var(--felt2);
  border-radius:10px;padding:10px 8px 14px;
  display:flex;flex-direction:column;gap:8px;transition:opacity .3s,border-color .3s
}
.board.non{border:1.5px solid rgba(224,85,85,.3)}
.board.oui{border:1.5px solid rgba(91,155,213,.3)}
/* Active board gets brighter border */
.board.non.active-board{border-color:rgba(224,85,85,.7)}
.board.oui.active-board{border-color:rgba(91,155,213,.7)}
/* Inactive board dims */
.board.inactive{opacity:.5;pointer-events:none}
.board.stuck{opacity:.4;pointer-events:none}
.board-hdr{display:flex;justify-content:space-between;align-items:center}
.board-name{font-family:'Cormorant Garamond',serif;font-size:13px;
            letter-spacing:.35em;font-style:italic}
.board.non .board-name{color:var(--non)}
.board.oui .board-name{color:var(--oui)}
.board-meta{font-size:9px;color:var(--muted)}
.done-badge{display:none;font-size:7px;letter-spacing:.12em;color:var(--muted);
            border:1px solid var(--muted);border-radius:3px;padding:1px 5px}
.board.stuck .done-badge{display:inline}

/* Stock + Hand row */
.board-top{display:flex;gap:6px;align-items:flex-end}
.board-top.rev{flex-direction:row-reverse}
.col-grp{display:flex;flex-direction:column;align-items:center;gap:3px}
.col-lbl{font-size:7px;letter-spacing:.12em;color:var(--muted);text-align:center}
.col-lbl.active{color:var(--gold)}
.col-cnt{font-size:7px;color:var(--muted);text-align:center}

/* Stock button */
.stock-btn{width:var(--cw);height:var(--ch);border-radius:5px;border:1.5px solid;
           display:flex;align-items:center;justify-content:center;
           font-size:18px;cursor:pointer;touch-action:manipulation;
           transition:border-color .15s,box-shadow .15s}
.stock-btn.has{
  background:repeating-linear-gradient(135deg,#0d2518 0,#0d2518 8px,#0a1c13 8px,#0a1c13 16px);
  border-color:rgba(200,168,75,.35);box-shadow:0 2px 8px rgba(0,0,0,.4)
}
.stock-btn.empty{background:transparent;border-color:var(--border);color:var(--muted);cursor:default}
.stock-btn.reshuffle{
  background:repeating-linear-gradient(135deg,#1a2d20 0,#1a2d20 8px,#0f1f15 8px,#0f1f15 16px);
  border-color:rgba(200,168,75,.2);cursor:pointer;
}

/* ── Center column ── */
.center-col{display:flex;flex-direction:column;align-items:center;gap:14px;padding-top:26px}
.ctr-section{display:flex;flex-direction:column;align-items:center;gap:5px}
.ctr-lbl{font-size:7px;letter-spacing:.18em;color:var(--muted);text-transform:uppercase}
.fnd-grid{display:grid;grid-template-columns:repeat(2,var(--cw));gap:5px}

/* ── Tableau columns ── */
.columns{display:flex;gap:4px;align-items:flex-start;min-height:500px}
.col-wrap{position:relative;width:var(--cw);flex-shrink:0}

/* ── Cards ── */
.card{position:absolute;width:var(--cw);height:var(--ch);border-radius:5px;
      cursor:grab;touch-action:none;-webkit-tap-highlight-color:transparent;
      transition:box-shadow .1s,opacity .15s}
.card.inline{position:relative;display:flex;flex-shrink:0}
.card.dragging-source{opacity:.25;pointer-events:none}
.card.face-down{border:1.5px solid rgba(200,168,75,.18);cursor:default}
.card.face-down::after{content:'';position:absolute;inset:3px;border-radius:3px}
.card.face-down.back-non{
  background:repeating-linear-gradient(135deg,#3d0a0a 0,#3d0a0a 7px,#5c1212 7px,#5c1212 14px);
}
.card.face-down.back-non::after{border:1px solid rgba(220,80,80,.22)}
.card.face-down.back-oui{
  background:repeating-linear-gradient(135deg,#0a1a3d 0,#0a1a3d 7px,#12285c 7px,#12285c 14px);
}
.card.face-down.back-oui::after{border:1px solid rgba(91,155,213,.22)}
.card.face-up{
  background:var(--card-bg);border:1.5px solid #c8b99a;
  box-shadow:0 2px 6px var(--card-sh);display:flex;flex-direction:column;
  justify-content:space-between;padding:3px 4px;
  font-family:'Cormorant Garamond',serif;font-size:12px;font-weight:700;line-height:1.15
}
.card.face-up.red{color:var(--red)}
.card.face-up.black{color:var(--bluecol)}
.card.face-up.selected{background:#fffbef;border-color:var(--gold);
  box-shadow:0 0 0 2px rgba(200,168,75,.5),0 2px 8px var(--card-sh)}
.card.face-up.sel-stack{background:#fffcf2;
  box-shadow:0 0 0 1px rgba(200,168,75,.3),0 2px 6px var(--card-sh)}
.card-mid{text-align:center;font-size:18px;line-height:1}
.card-bot{text-align:right;transform:rotate(180deg)}

/* Blocked card — X overlay */
.card.blocked{cursor:not-allowed}
.card.blocked::before{
  content:'✕';position:absolute;inset:0;
  display:flex;align-items:center;justify-content:center;
  font-size:24px;font-weight:900;color:rgba(210,40,40,.9);
  font-family:'Courier Prime',monospace;pointer-events:none;z-index:2;
  background:rgba(60,0,0,.1);border-radius:4px;
}

/* Empty slot */
.slot{width:var(--cw);height:var(--ch);border-radius:5px;border:1.5px dashed;
      cursor:pointer;flex-shrink:0;display:flex;align-items:center;justify-content:center;
      font-size:18px;font-family:'Cormorant Garamond',serif;transition:border-color .15s,background .15s}
.board.non .slot{border-color:rgba(224,85,85,.25);color:rgba(224,85,85,.2)}
.board.oui .slot{border-color:rgba(91,155,213,.25);color:rgba(91,155,213,.2)}
.center-col .slot{border-color:rgba(200,168,75,.2);color:rgba(200,168,75,.15)}

/* Drop targets */
.drop-ok{border-color:var(--gold)!important;background:rgba(200,168,75,.12)!important;
         box-shadow:0 0 0 2px rgba(200,168,75,.3)!important}
.card.drop-card{box-shadow:0 0 0 2px var(--gold),0 2px 8px var(--card-sh)!important;
                background:#fffef5!important}

/* ── Drag ghost ── */
#ghost{position:fixed;pointer-events:none;z-index:9999;display:none;
       transform-origin:top left;filter:drop-shadow(0 8px 24px rgba(0,0,0,.6))}
#ghost .card{position:relative!important;display:flex!important;
             pointer-events:none;opacity:1!important;margin-bottom:-36px}
#ghost .card:last-child{margin-bottom:0}

/* ── Buttons ── */
.new-btn{display:block;margin:16px auto 0;padding:7px 26px;
         background:transparent;border:1px solid var(--border);border-radius:4px;
         color:var(--muted);font-family:'Courier Prime',monospace;
         font-size:10px;letter-spacing:.18em;cursor:pointer;
         transition:border-color .15s,color .15s;text-transform:uppercase;
         touch-action:manipulation}
.new-btn:hover{border-color:var(--gold);color:var(--gold)}

/* ── Game Over overlay ── */
#go-overlay{display:none;position:fixed;inset:0;background:rgba(0,0,0,.9);
            align-items:center;justify-content:center;z-index:10000;
            padding:16px;overflow-y:auto}
#go-overlay.show{display:flex}
.go-box{background:#08160e;border:2px solid var(--gold);border-radius:12px;
        padding:28px 36px;width:100%;max-width:460px;
        font-family:'Cormorant Garamond',serif;display:flex;flex-direction:column;gap:18px}
.go-title{text-align:center;font-size:21px;font-weight:700;letter-spacing:.3em;
          color:var(--gold);text-transform:uppercase}
.go-scores{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.go-sbox{background:#0d2518;border-radius:8px;padding:12px;text-align:center}
.go-camp{font-size:10px;letter-spacing:.25em;text-transform:uppercase;margin-bottom:4px}
.go-camp.non{color:var(--non)}.go-camp.oui{color:var(--oui)}
.go-num{font-size:26px;font-weight:700;color:var(--text)}
.go-den{font-size:12px;color:var(--muted)}
.go-stats{display:flex;gap:24px;justify-content:center}
.go-stat{text-align:center}
.go-stat-lbl{font-size:8px;letter-spacing:.18em;color:var(--muted);
             text-transform:uppercase;margin-bottom:2px;font-family:'Courier Prime',monospace}
.go-stat-val{font-size:24px;font-weight:700;color:var(--gold)}
.go-save{display:flex;gap:8px;align-items:center;
         border-top:1px solid var(--border);padding-top:14px}
.go-save input{flex:1;padding:7px 10px;background:#0d2518;border:1px solid var(--border);
               border-radius:4px;color:var(--text);font-family:'Courier Prime',monospace;
               font-size:13px;outline:none}
.go-save input:focus{border-color:var(--gold)}
.go-save input::placeholder{color:var(--muted)}
.go-save-btn{padding:7px 14px;background:var(--gold);border:none;border-radius:4px;
             color:#08160e;font-family:'Courier Prime',monospace;font-size:10px;
             letter-spacing:.1em;cursor:pointer;font-weight:700;white-space:nowrap;
             touch-action:manipulation;transition:background .15s}
.go-save-btn:hover{background:var(--gold2)}
.go-save-btn:disabled{background:var(--muted);cursor:default}
.scoreboard{border-top:1px solid var(--border);padding-top:12px}
.sb-title{font-size:9px;letter-spacing:.2em;color:var(--muted);text-transform:uppercase;
          margin-bottom:8px;font-family:'Courier Prime',monospace;text-align:center}
.sb table{width:100%;border-collapse:collapse;font-family:'Courier Prime',monospace;
          font-size:11px;color:var(--text)}
.sb th{text-align:left;color:var(--muted);font-weight:400;font-size:8px;letter-spacing:.12em;
       padding:3px 5px;border-bottom:1px solid var(--border);text-transform:uppercase}
.sb td{padding:4px 5px;border-bottom:1px solid rgba(26,61,38,.4)}
.sb tr.hl td{color:var(--gold)}
.sb .rk{color:var(--muted);width:22px}
.sb .ec{text-align:center}
.sb .tm{text-align:right;color:var(--muted)}
.go-newbtn{padding:9px;width:100%;background:transparent;border:1px solid var(--border);
           border-radius:6px;color:var(--muted);font-family:'Courier Prime',monospace;
           font-size:10px;letter-spacing:.18em;cursor:pointer;
           transition:border-color .15s,color .15s;text-transform:uppercase;touch-action:manipulation}
.go-newbtn:hover{border-color:var(--gold);color:var(--gold)}
</style>
</head>
<body>

<div class="hdr">
  <div>
    <h1>Deux Solitudes</h1>
    <div class="subtitle">A Quebec Referendum Solitaire Game</div>
  </div>
  <div class="timer" id="timer">00:00</div>
</div>

<div class="bal-row">
  <span class="bal-score non" id="sc-non">0</span>
  <div class="bal-track"><div class="bal-fill" id="bal-fill"></div><div class="bal-mid"></div></div>
  <span class="bal-score oui" id="sc-oui">0</span>
</div>
<div class="bal-lbl" id="bal-lbl"></div>

<!-- Turn indicator -->
<div class="turn-bar">
  <span class="turn-chip non" id="chip-non">NON</span>
  <span class="turn-arrow">›</span>
  <span class="turn-chip oui" id="chip-oui">OUI</span>
</div>
<div class="skip-notice" id="skip-notice"></div>

<div class="game-layout">
  <div class="board non" id="bd-0">
    <div class="board-hdr">
      <span class="board-name">NON</span>
      <span class="done-badge">BLOQUÉ</span>
      <span class="board-meta" id="bm-0">0 / 52</span>
    </div>
    <div class="board-top" id="bt-0"></div>
    <div class="columns" id="bc-0"></div>
  </div>

  <div class="center-col">
    <div class="ctr-section">
      <div class="ctr-lbl">Fondation</div>
      <div class="fnd-grid" id="foundation"></div>
    </div>
  </div>

  <div class="board oui" id="bd-1">
    <div class="board-hdr">
      <span class="board-name">OUI</span>
      <span class="done-badge">BLOQUÉ</span>
      <span class="board-meta" id="bm-1">0 / 52</span>
    </div>
    <div class="board-top rev" id="bt-1"></div>
    <div class="columns" id="bc-1"></div>
  </div>
</div>

<button class="new-btn" onclick="newGame()">Nouvelle partie</button>
<div id="ghost"></div>

<div id="go-overlay">
  <div class="go-box">
    <div class="go-title">Partie terminée</div>
    <div class="go-scores">
      <div class="go-sbox"><div class="go-camp non">NON</div>
        <span class="go-num" id="go-non">0</span><span class="go-den"> / 52</span></div>
      <div class="go-sbox"><div class="go-camp oui">OUI</div>
        <span class="go-num" id="go-oui">0</span><span class="go-den"> / 52</span></div>
    </div>
    <div class="go-stats">
      <div class="go-stat"><div class="go-stat-lbl">Écart</div><div class="go-stat-val" id="go-ecart">—</div></div>
      <div class="go-stat"><div class="go-stat-lbl">Temps</div><div class="go-stat-val" id="go-temps">—</div></div>
    </div>
    <div class="go-save">
      <input type="text" id="go-name" placeholder="Votre nom…" maxlength="20">
      <button class="go-save-btn" id="go-save-btn" onclick="saveScore()">Sauver</button>
    </div>
    <div class="scoreboard">
      <div class="sb-title">Tableau des scores</div>
      <div class="sb"><table>
        <thead><tr>
          <th class="rk">#</th><th>Nom</th>
          <th class="ec">Écart</th><th class="tm">Temps</th>
        </tr></thead>
        <tbody id="sb-body"></tbody>
      </table></div>
    </div>
    <button class="go-newbtn" onclick="newGame()">Nouvelle partie</button>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════
//  CONSTANTS
// ═══════════════════════════════════════════════════════
const SUITS    = ['♥','♦','♠','♣'];
const SUIT_IDX = {'♥':0,'♦':1,'♠':2,'♣':3};
const VALUES   = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
const RED      = new Set(['♥','♦']);
let _id = 0;

const mkCard   = (s,v) => ({suit:s,val:v,num:VALUES.indexOf(v)+1,red:RED.has(s),faceUp:false,id:_id++});
const shuffle  = a => { for(let i=a.length-1;i>0;i--){const j=0|Math.random()*(i+1);[a[i],a[j]]=[a[j],a[i]];} return a; };
const mkDeck   = () => shuffle(SUITS.flatMap(s=>VALUES.map(v=>mkCard(s,v))));
const deal     = deck => {
  const cols=Array.from({length:7},()=>[]);
  let i=0;
  for(let c=0;c<7;c++) for(let r=0;r<=c;r++){const card=deck[i++];card.faceUp=(r===c);cols[c].push(card);}
  return {cols,rest:deck.slice(i)};
};
const canStack      = (c,on) => !on?c.num===13:on.faceUp&&on.red!==c.red&&on.num===c.num+1;
const canFoundation = (c,p)  => !p.length?c.num===1:p[p.length-1].suit===c.suit&&c.num===p[p.length-1].num+1;

// ═══════════════════════════════════════════════════════
//  STATE
// ═══════════════════════════════════════════════════════
let G, timerInterval;

function initState(){
  const d0=mkDeck(),d1=mkDeck();
  const b0=deal(d0),b1=deal(d1);
  return {
    boards:[
      {cols:b0.cols, stock:b0.rest, waste:[], blocked:new Set()},
      {cols:b1.cols, stock:b1.rest, waste:[], blocked:new Set()},
    ],
    foundation:[[],[],[],[]],
    scores:[0,0],
    turn:0,        // 0=NON, 1=OUI — whose move it is
    selected:null, // {src:'hand',bi} | {bi,ci,idx}
    moves:0,
    startTime:Date.now(), elapsed:0, gameOver:false,
  };
}

function newGame(){
  clearInterval(timerInterval);
  G=initState();
  document.getElementById('go-overlay').classList.remove('show');
  document.getElementById('go-save-btn').disabled=false;
  document.getElementById('go-save-btn').textContent='Sauver';
  document.getElementById('go-name').value='';
  document.getElementById('skip-notice').textContent='';
  startTimer(); render();
}

// ═══════════════════════════════════════════════════════
//  TIMER
// ═══════════════════════════════════════════════════════
function startTimer(){
  G.startTime=Date.now(); G.elapsed=0;
  document.getElementById('timer').textContent='00:00';
  timerInterval=setInterval(()=>{
    if(!G.gameOver){
      G.elapsed=Math.floor((Date.now()-G.startTime)/1000);
      document.getElementById('timer').textContent=fmtTime(G.elapsed);
    }
  },500);
}
const fmtTime = s=>`${String(0|s/60).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;

// ═══════════════════════════════════════════════════════
//  BLOCKED CARD HELPERS
// ═══════════════════════════════════════════════════════
const blockKey  = c => `${c.suit}${c.num}`;
const isBlocked = (card,bi) => G.boards[bi].blocked.has(blockKey(card));

// When camp `bi` plays a card to foundation, mark its twin blocked for the other camp
function markBlocked(card,bi){
  G.boards[1-bi].blocked.add(blockKey(card));
}

// ═══════════════════════════════════════════════════════
//  INTEGRITY CHECK
// ═══════════════════════════════════════════════════════
function assertOK(){
  const seen=new Map();
  const chk=(c,loc)=>{
    if(seen.has(c.id)) console.error(`DOUBLON id=${c.id}(${c.val}${c.suit}):${seen.get(c.id)}&${loc}`);
    else seen.set(c.id,loc);
  };
  G.boards.forEach((bd,bi)=>{
    bd.cols.forEach((col,ci)=>col.forEach((c,i)=>chk(c,`b${bi}c${ci}[${i}]`)));
    bd.waste.forEach((c,i)=>chk(c,`b${bi}w[${i}]`));
    bd.stock.forEach((c,i)=>chk(c,`b${bi}s[${i}]`));
  });
  G.foundation.forEach((p,fi)=>p.forEach((c,i)=>chk(c,`fnd${fi}[${i}]`)));
  if(seen.size!==104) console.error(`TOTAL:${seen.size}/104`);
}

// ═══════════════════════════════════════════════════════
//  MOVE VALIDITY HELPERS
// ═══════════════════════════════════════════════════════

// Can this card be the BOTTOM of a moving stack (i.e., be selected as source)?
function canPickUp(card,bi){
  return card.faceUp && !isBlocked(card,bi);
}

// Can a card be placed ON TOP of `onto` in camp bi?
// `onto` = null means empty column (always ok for kings).
function canDropOnto(onto,bi){
  if(!onto) return true; // empty slot
  return !isBlocked(onto,bi); // blocked cards can't receive
}

// ─── What moves are valid for camp bi? ─────────────────
// Returns true if at least one card placement exists
function hasValidPlacement(bi){
  const bd=G.boards[bi];
  const fnd=G.foundation;

  // Waste top → foundation or column?
  if(bd.waste.length){
    const w=bd.waste[bd.waste.length-1];
    if(!isBlocked(w,bi)){
      if(canFoundation(w,fnd[SUIT_IDX[w.suit]])) return true;
      for(let ci=0;ci<7;ci++){
        const col=bd.cols[ci];
        const top=col.length?col[col.length-1]:null;
        if(canDropOnto(top,bi)&&canStack(w,top)) return true;
      }
    }
  }

  // Tableau moves
  for(let ci=0;ci<7;ci++){
    const col=bd.cols[ci];
    for(let idx=col.length-1;idx>=0;idx--){
      const card=col[idx];
      if(!card.faceUp) break;
      if(!canPickUp(card,bi)) continue; // blocked can't be source

      const moving=col.slice(idx);
      const mTop=moving[0];

      // To foundation (only single card)
      if(moving.length===1&&canFoundation(mTop,fnd[SUIT_IDX[mTop.suit]])) return true;

      // To another column
      for(let dci=0;dci<7;dci++){
        if(dci===ci) continue;
        const dc=bd.cols[dci];
        const onto=dc.length?dc[dc.length-1]:null;
        if(canDropOnto(onto,bi)&&canStack(mTop,onto)) return true;
      }
    }
  }
  return false;
}

function canDraw(bi){
  const bd=G.boards[bi];
  return bd.stock.length>0||(bd.waste.length>0); // can reshuffle if waste has cards
}

// ─── TURN MANAGEMENT ────────────────────────────────────
function nextTurn(){
  const other=1-G.turn;

  // Try to give turn to other player
  if(hasValidPlacement(other)||canDraw(other)){
    G.turn=other;
    G.selected=null;
    document.getElementById('skip-notice').textContent='';
    checkGameOver();
    return;
  }

  // Other player can't move — try keeping turn with current player
  if(hasValidPlacement(G.turn)||canDraw(G.turn)){
    // Show skip notice
    const names=['NON','OUI'];
    document.getElementById('skip-notice').textContent=
      `${names[other]} n'a plus de mouvement — ${names[G.turn]} rejoue`;
    checkGameOver();
    return;
  }

  // Neither can move
  G.gameOver=true;
  clearInterval(timerInterval);
  setTimeout(showGameOver,700);
}

function checkGameOver(){
  if(G.gameOver) return;
  if(!hasValidPlacement(0)&&!canDraw(0)&&!hasValidPlacement(1)&&!canDraw(1)){
    G.gameOver=true;
    clearInterval(timerInterval);
    setTimeout(showGameOver,700);
  }
}

function showGameOver(){
  const ecart=Math.abs(G.scores[0]-G.scores[1]);
  document.getElementById('go-non').textContent=G.scores[0];
  document.getElementById('go-oui').textContent=G.scores[1];
  document.getElementById('go-ecart').textContent=ecart;
  document.getElementById('go-temps').textContent=fmtTime(G.elapsed);
  loadScoreboard();
  document.getElementById('go-overlay').classList.add('show');
}

// ═══════════════════════════════════════════════════════
//  DRAW
// ═══════════════════════════════════════════════════════
function drawCard(bi){
  if(bi!==G.turn) return; // only active player can draw
  const bd=G.boards[bi];
  if(!bd.stock.length){
    if(!bd.waste.length) return;
    // Reshuffle waste into stock
    bd.waste.forEach(c=>c.faceUp=false);
    bd.stock=shuffle(bd.waste);
    bd.waste=[];
  }
  const card=bd.stock.shift();
  card.faceUp=true;
  bd.waste.push(card);
  G.selected={src:'hand',bi};
  // Drawing does NOT alternate turn
  render();
}

// ═══════════════════════════════════════════════════════
//  RESOLVE MOVE  (shared by click + drag)
// ═══════════════════════════════════════════════════════
// src: {src:'hand',bi} | {bi,ci,idx}
// dst: {type:'col',bi,ci} | {type:'empty',bi,ci} | {type:'fnd',fi}
function resolveMove(src,dst){
  const bi=src.src==='hand'?src.bi:src.bi;
  if(bi!==G.turn) return false; // wrong player

  let cards, fromHand=false;
  if(src.src==='hand'){
    const w=G.boards[bi].waste;
    if(!w.length) return false;
    const top=w[w.length-1];
    if(isBlocked(top,bi)) return false; // blocked waste card: immovable
    cards=[top]; fromHand=true;
  } else {
    const col=G.boards[bi].cols[src.ci];
    const card=col[src.idx];
    if(!canPickUp(card,bi)) return false; // blocked or face-down
    cards=col.slice(src.idx);
  }
  const topCard=cards[0];

  if(dst.type==='col'){
    if(dst.bi!==bi) return false;
    const dc=G.boards[bi].cols[dst.ci];
    const onto=dc.length?dc[dc.length-1]:null;
    if(!canDropOnto(onto,bi)) return false; // can't drop onto blocked card
    if(!canStack(topCard,onto)) return false;
    dc.push(...cards);
  } else if(dst.type==='empty'){
    if(dst.bi!==bi) return false;
    if(topCard.num!==13) return false;
    G.boards[bi].cols[dst.ci].push(...cards);
  } else if(dst.type==='fnd'){
    if(cards.length>1) return false;
    if(isBlocked(topCard,bi)) return false;
    const pile=G.foundation[dst.fi];
    if(topCard.suit!==SUITS[dst.fi]||!canFoundation(topCard,pile)) return false;
    pile.push(topCard);
    G.scores[bi]++;
    markBlocked(topCard,bi);
    commitSrc(src,fromHand,bi);
    G.moves++; G.selected=null;
    assertOK(); nextTurn(); render(); return true;
  } else return false;

  commitSrc(src,fromHand,bi);
  G.moves++; G.selected=null;
  assertOK(); nextTurn(); render(); return true;
}

function commitSrc(src,fromHand,bi){
  if(fromHand){
    G.boards[bi].waste.pop();
  } else {
    const fc=G.boards[bi].cols[src.ci];
    fc.splice(src.idx);
    if(fc.length) fc[fc.length-1].faceUp=true;
  }
}

// ═══════════════════════════════════════════════════════
//  CLICK HANDLERS
// ═══════════════════════════════════════════════════════
let suppressClick=false;

function clickStock(bi){
  if(suppressClick) return;
  drawCard(bi);
}

function clickHand(bi){
  if(suppressClick) return;
  if(bi!==G.turn) return;
  const w=G.boards[bi].waste;
  if(!w.length) return;
  const top=w[w.length-1];
  if(isBlocked(top,bi)) return; // blocked: not selectable
  const sel=G.selected;
  if(sel?.src==='hand'&&sel.bi===bi) G.selected=null;
  else G.selected={src:'hand',bi};
  render();
}

function clickCard(bi,ci,idx){
  if(suppressClick) return;
  if(bi!==G.turn) return;
  const col=G.boards[bi].cols[ci];
  const card=col[idx];
  const sel=G.selected;

  // Flip face-down top
  if(!card.faceUp){
    if(idx===col.length-1){card.faceUp=true; G.moves++; nextTurn();}
    render(); return;
  }

  // Blocked card: never selectable as source
  if(isBlocked(card,bi)){
    G.selected=null; render(); return;
  }

  if(!sel){G.selected={bi,ci,idx};render();return;}

  // Deselect same
  if(sel.src!=='hand'&&sel.bi===bi&&sel.ci===ci&&sel.idx===idx){
    G.selected=null;render();return;
  }

  // Try to place
  const ok=resolveMove(sel,{type:'col',bi,ci});
  if(!ok) G.selected={bi,ci,idx};
  render();
}

function clickEmpty(bi,ci){
  if(suppressClick) return;
  if(bi!==G.turn) return;
  if(G.selected) resolveMove(G.selected,{type:'empty',bi,ci});
  else {
    // Try waste top as king
    const w=G.boards[bi].waste;
    if(w.length&&!isBlocked(w[w.length-1],bi))
      resolveMove({src:'hand',bi},{type:'empty',bi,ci});
  }
  render();
}

function clickFoundation(fi){
  if(suppressClick) return;
  const sel=G.selected;
  const bi=G.turn;
  if(sel){
    resolveMove(sel,{type:'fnd',fi});
  } else {
    // Try waste top
    const w=G.boards[bi].waste;
    if(w.length) resolveMove({src:'hand',bi},{type:'fnd',fi});
  }
  render();
}

// ═══════════════════════════════════════════════════════
//  SCOREBOARD
// ═══════════════════════════════════════════════════════
let lastSaved=-1;
const SCORE_KEY='deux-solitudes-v3';

async function loadScoreboard(){
  let e=[];
  try{const r=await window.storage.get(SCORE_KEY,true);if(r)e=JSON.parse(r.value);}catch(_){}
  renderSB(e);
}
async function saveScore(){
  const name=document.getElementById('go-name').value.trim();
  if(!name) return;
  const btn=document.getElementById('go-save-btn'); btn.disabled=true;
  const entry={name,ecart:Math.abs(G.scores[0]-G.scores[1]),time:G.elapsed,
               date:new Date().toLocaleDateString('fr-CA')};
  let e=[];
  try{const r=await window.storage.get(SCORE_KEY,true);if(r)e=JSON.parse(r.value);}catch(_){}
  e.push(entry); e.sort((a,b)=>a.ecart-b.ecart||a.time-b.time);
  if(e.length>20)e=e.slice(0,20);
  lastSaved=e.indexOf(entry);
  try{await window.storage.set(SCORE_KEY,JSON.stringify(e),true);}catch(_){}
  renderSB(e); btn.textContent='✓ Sauvé';
}
function renderSB(e){
  const tbody=document.getElementById('sb-body'); tbody.innerHTML='';
  if(!e.length){
    tbody.innerHTML='<tr><td colspan="4" style="text-align:center;color:var(--muted);padding:10px">Aucun score</td></tr>';
    return;
  }
  e.slice(0,10).forEach((en,i)=>{
    const tr=document.createElement('tr');
    if(i===lastSaved)tr.className='hl';
    tr.innerHTML=`<td class="rk">${i+1}</td><td>${en.name}</td><td class="ec">${en.ecart}</td><td class="tm">${fmtTime(en.time)}</td>`;
    tbody.appendChild(tr);
  });
}

// ═══════════════════════════════════════════════════════
//  DRAG & DROP  — Pointer Events (mouse + touch)
// ═══════════════════════════════════════════════════════
const DRAG_THRESHOLD=6;
const ghost=document.getElementById('ghost');
let DRAG=null;
const DSM=new Map();

const srcKey=src=>src.src==='hand'?`h${src.bi}`:`c${src.bi}-${src.ci}-${src.idx}`;

function buildGhost(cards){
  ghost.innerHTML='';
  cards.forEach(c=>{const el=mkCardEl(c,false,false,null);el.style.position='relative';ghost.appendChild(el);});
  ghost.style.display='block'; ghost.style.width='var(--cw)';
}
function moveGhost(x,y){ghost.style.left=(x-DRAG.grabX)+'px';ghost.style.top=(y-DRAG.grabY)+'px';}
function hideGhost(){ghost.style.display='none';ghost.innerHTML='';}

function findDrop(x,y){
  ghost.style.pointerEvents='none';
  for(const el of document.elementsFromPoint(x,y)) if(el.dataset.drop) return el;
  return null;
}
function clearHL(){
  if(DRAG?.dropEl){DRAG.dropEl.classList.remove('drop-ok','drop-card');DRAG.dropEl=null;}
}
function highlightDrop(x,y){
  clearHL(); if(!DRAG) return;
  const el=findDrop(x,y); if(!el) return;
  const d=el.dataset;
  const bi=DRAG.src.src==='hand'?DRAG.src.bi:DRAG.src.bi;
  if(bi!==G.turn) return;
  let dst;
  if(d.drop==='col')     dst={type:'col',  bi:+d.bi,ci:+d.ci};
  else if(d.drop==='mt') dst={type:'empty',bi:+d.bi,ci:+d.ci};
  else if(d.drop==='fn') dst={type:'fnd',  fi:+d.fi};
  else return;

  const top=DRAG.cards[0];
  let ok=false;
  if(dst.type==='col'){
    if(dst.bi===bi){
      const dc=G.boards[bi].cols[dst.ci];
      const onto=dc.length?dc[dc.length-1]:null;
      ok=canDropOnto(onto,bi)&&canStack(top,onto);
    }
  } else if(dst.type==='empty'){
    ok=dst.bi===bi&&top.num===13;
  } else if(dst.type==='fnd'){
    ok=DRAG.cards.length===1&&!isBlocked(top,bi)&&
       top.suit===SUITS[dst.fi]&&canFoundation(top,G.foundation[dst.fi]);
  }

  if(ok){DRAG.dropEl=el;el.classList.add(d.drop==='col'?'drop-card':'drop-ok');}
}

function attachDrag(el,src,getCards){
  el.addEventListener('pointerdown',e=>{
    if(e.button!==0&&e.pointerType==='mouse') return;
    const bi=src.src==='hand'?src.bi:src.bi;
    if(bi!==G.turn) return;
    const cards=getCards();
    if(!cards[0]?.faceUp||isBlocked(cards[0],bi)) return;
    e.stopPropagation(); el.setPointerCapture(e.pointerId);
    const r=el.getBoundingClientRect();
    DRAG={pointerId:e.pointerId,src,cards,startX:e.clientX,startY:e.clientY,
          grabX:e.clientX-r.left,grabY:e.clientY-r.top,isDragging:false,sourceEls:[],dropEl:null};
  },{passive:false});

  el.addEventListener('pointermove',e=>{
    if(!DRAG||DRAG.pointerId!==e.pointerId) return;
    e.preventDefault();
    if(!DRAG.isDragging&&Math.hypot(e.clientX-DRAG.startX,e.clientY-DRAG.startY)>DRAG_THRESHOLD){
      DRAG.isDragging=true; DRAG.cards=getCards(); buildGhost(DRAG.cards); moveGhost(e.clientX,e.clientY); markSrc();
    }
    if(DRAG.isDragging){moveGhost(e.clientX,e.clientY);highlightDrop(e.clientX,e.clientY);}
  },{passive:false});

  el.addEventListener('pointerup',e=>{
    if(!DRAG||DRAG.pointerId!==e.pointerId) return;
    e.stopPropagation();
    if(DRAG.isDragging){
      suppressClick=true; setTimeout(()=>suppressClick=false,150);
      const de=findDrop(e.clientX,e.clientY);
      if(de?.dataset.drop){
        const d=de.dataset; let dst;
        if(d.drop==='col')     dst={type:'col',  bi:+d.bi,ci:+d.ci};
        else if(d.drop==='mt') dst={type:'empty',bi:+d.bi,ci:+d.ci};
        else if(d.drop==='fn') dst={type:'fnd',  fi:+d.fi};
        if(dst) resolveMove(DRAG.src,dst);
      }
      clearHL(); unmarkSrc(); hideGhost(); render();
    }
    DRAG=null;
  });
  el.addEventListener('pointercancel',()=>{
    if(!DRAG) return; clearHL(); unmarkSrc(); hideGhost(); DRAG=null; render();
  });
}

function markSrc(){
  if(!DRAG) return;
  const toMark=[];
  if(DRAG.src.src==='hand'){
    const els=DSM.get(srcKey(DRAG.src))||[]; toMark.push(...els);
  } else {
    const {bi,ci,idx}=DRAG.src;
    const col=G.boards[bi].cols[ci];
    for(let i=idx;i<col.length;i++){const els=DSM.get(`c${bi}-${ci}-${i}`)||[];toMark.push(...els);}
  }
  DRAG.sourceEls=toMark; toMark.forEach(e=>e.classList.add('dragging-source'));
}
function unmarkSrc(){if(DRAG)DRAG.sourceEls.forEach(e=>e.classList.remove('dragging-source'));}

// ═══════════════════════════════════════════════════════
//  RENDER
// ═══════════════════════════════════════════════════════
function mkCardEl(card,sel,stk,bi){
  const backCls=bi===0?'back-non':bi===1?'back-oui':'';
  const blocked=bi!=null&&card.faceUp&&isBlocked(card,bi);
  const el=document.createElement('div');
  el.className=['card',
    card.faceUp
      ?`face-up ${card.red?'red':'black'}${sel?' selected':''}${stk?' sel-stack':''}${blocked?' blocked':''}`
      :`face-down ${backCls}`
  ].join(' ');
  if(card.faceUp){
    const t=document.createElement('div'); t.textContent=`${card.val}${card.suit}`;
    const m=document.createElement('div'); m.className='card-mid'; m.textContent=card.suit;
    const b=document.createElement('div'); b.className='card-bot'; b.textContent=`${card.val}${card.suit}`;
    el.append(t,m,b);
  }
  return el;
}

function render(){
  DSM.clear();
  const sel=G.selected;
  const sc=G.scores; const tot=sc[0]+sc[1];
  const pct=tot>0?sc[0]/tot:.5; const diff=Math.abs(sc[0]-sc[1]);

  // Balance bar
  document.getElementById('sc-non').textContent=sc[0];
  document.getElementById('sc-oui').textContent=sc[1];
  document.getElementById('bal-fill').style.width=`${pct*100}%`;
  const lbl=document.getElementById('bal-lbl');
  if(diff===0&&tot>0){lbl.textContent='⚖ Équilibre parfait';lbl.className='bal-lbl eq';}
  else if(diff>0){lbl.textContent=`écart : ${diff}`;lbl.className='bal-lbl';}
  else lbl.textContent='';

  // Turn chips
  const chipN=document.getElementById('chip-non');
  const chipO=document.getElementById('chip-oui');
  chipN.className='turn-chip non'+(G.turn===0?' active-non':'');
  chipO.className='turn-chip oui'+(G.turn===1?' active-oui':'');

  // Foundation
  const fndEl=document.getElementById('foundation'); fndEl.innerHTML='';
  SUITS.forEach((suit,fi)=>{
    const pile=G.foundation[fi];
    if(pile.length){
      const el=mkCardEl(pile[pile.length-1],false,false,null);
      el.classList.add('inline'); el.dataset.drop='fn'; el.dataset.fi=fi;
      el.addEventListener('click',()=>clickFoundation(fi)); fndEl.appendChild(el);
    } else {
      const s=document.createElement('div'); s.className='slot';
      s.textContent=suit; s.dataset.drop='fn'; s.dataset.fi=fi;
      s.addEventListener('click',()=>clickFoundation(fi)); fndEl.appendChild(s);
    }
  });

  // Boards
  G.boards.forEach((bd,bi)=>{
    const isActive=bi===G.turn;
    const stuck=!hasValidPlacement(bi)&&!canDraw(bi);
    const bEl=document.getElementById(`bd-${bi}`);
    bEl.classList.toggle('stuck',stuck&&!isActive);
    bEl.classList.toggle('inactive',!isActive);
    bEl.classList.toggle('active-board',isActive);
    document.getElementById(`bm-${bi}`).textContent=`${sc[bi]} / 52`;

    // Board top: stock + waste hand
    const btEl=document.getElementById(`bt-${bi}`); btEl.innerHTML='';

    // Stock
    const sg=document.createElement('div'); sg.className='col-grp';
    const sl=document.createElement('div'); sl.className='col-lbl'; sl.textContent='PIOCHE';
    const sb=document.createElement('div');
    const canReshuffle=!bd.stock.length&&bd.waste.length>0;
    sb.className='stock-btn '+(bd.stock.length?'has':canReshuffle?'reshuffle':'empty');
    if((bd.stock.length||canReshuffle)&&isActive) sb.addEventListener('click',()=>clickStock(bi));
    if(canReshuffle){
      const ico=document.createElement('span'); ico.textContent='↺';
      ico.style.cssText='font-size:22px;color:var(--muted)'; sb.appendChild(ico);
    }
    const sc2=document.createElement('div'); sc2.className='col-cnt';
    sc2.textContent=bd.stock.length?bd.stock.length+' carte'+(bd.stock.length>1?'s':''):
                    canReshuffle?'Rebrasser':'Vide';
    sg.append(sl,sb,sc2); btEl.appendChild(sg);

    // Waste (hand)
    const hg=document.createElement('div'); hg.className='col-grp';
    const wTop=bd.waste.length?bd.waste[bd.waste.length-1]:null;
    const wBlocked=wTop?isBlocked(wTop,bi):false;
    const hl=document.createElement('div');
    hl.className='col-lbl'+(wTop&&!wBlocked?' active':'');
    hl.textContent=wTop?'EN MAIN':'—';
    hg.appendChild(hl);

    if(wTop){
      const handSel=sel?.src==='hand'&&sel.bi===bi;
      const el=mkCardEl(wTop,handSel&&!wBlocked,false,bi); el.classList.add('inline');
      if(!wBlocked&&isActive){
        const hsrc={src:'hand',bi};
        el.addEventListener('click',()=>clickHand(bi));
        attachDrag(el,hsrc,()=>[wTop]);
        DSM.set(srcKey(hsrc),[el]);
      }
      hg.appendChild(el);
    } else {
      const s=document.createElement('div'); s.className='slot'; s.style.opacity='.28';
      hg.appendChild(s);
    }
    const wdepth=document.createElement('div'); wdepth.className='col-cnt';
    wdepth.textContent=bd.waste.length>1?`+${bd.waste.length-1}`:' ';
    hg.appendChild(wdepth);
    btEl.appendChild(hg);

    // Columns
    const colsEl=document.getElementById(`bc-${bi}`); colsEl.innerHTML='';
    bd.cols.forEach((col,ci)=>{
      const wrap=document.createElement('div'); wrap.className='col-wrap';
      if(!col.length){
        const s=document.createElement('div'); s.className='slot'; s.style.position='relative';
        s.dataset.drop='mt'; s.dataset.bi=bi; s.dataset.ci=ci;
        if(isActive) s.addEventListener('click',()=>clickEmpty(bi,ci));
        wrap.style.height='var(--ch)'; wrap.appendChild(s);
        colsEl.appendChild(wrap); return;
      }
      let h=0; col.forEach((c,i)=>{h+=i<col.length-1?(c.faceUp?32:17):68;});
      wrap.style.height=Math.max(h,68)+'px';
      let y=0;
      col.forEach((card,i)=>{
        const isTop=i===col.length-1;
        const blocked=card.faceUp&&isBlocked(card,bi);
        const isSel=sel&&sel.src!=='hand'&&sel.bi===bi&&sel.ci===ci&&sel.idx===i&&!blocked;
        const isStk=sel&&sel.src!=='hand'&&sel.bi===bi&&sel.ci===ci&&sel.idx!=null&&i>sel.idx;
        const el=mkCardEl(card,isSel,isStk,bi); el.style.top=y+'px';

        // Drop target: top card that is NOT blocked
        if(isTop&&card.faceUp&&!blocked){
          el.dataset.drop='col'; el.dataset.bi=bi; el.dataset.ci=ci;
        }
        if(isActive) el.addEventListener('click',()=>clickCard(bi,ci,i));

        // Draggable: face-up, not blocked
        if(card.faceUp&&!blocked&&isActive){
          const csrc={bi,ci,idx:i};
          attachDrag(el,csrc,()=>[...col.slice(i)]);
          const k=srcKey(csrc); if(!DSM.has(k))DSM.set(k,[]); DSM.get(k).push(el);
        }
        wrap.appendChild(el);
        if(!isTop) y+=card.faceUp?32:17;
      });
      colsEl.appendChild(wrap);
    });
  });
}

// ── Boot ──────────────────────────────────────────────
newGame();
</script>
</body>
</html>
